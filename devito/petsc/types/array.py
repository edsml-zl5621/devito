from functools import cached_property
import numpy as np
from ctypes import POINTER

from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import dtype_to_ctype
from devito.symbolics import FieldFromComposite

from .object import DM


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('dimensions', 'shape', 'liveness', 'coefficients',
                    'space_order', 'dmda'))

    def __init_finalize__(self, *args, **kwargs):

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))
        self._shape = kwargs.get('shape')
        self._space_order = kwargs.get('space_order', 1)
        self._dmda = kwargs.get('dmda')

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape(self):
        return self._shape

    @property
    def space_order(self):
        return self._space_order

    @cached_property
    def _shape_with_inhalo(self):
        """
        Shape of the domain+inhalo region. The inhalo region comprises the
        outhalo as well as any additional "ghost" layers for MPI halo
        exchanges. Data in the inhalo region are exchanged when running
        Operators to maintain consistent values as in sequential runs.

        Notes
        -----
        Typically, this property won't be used in user code, but it may come
        in handy for testing or debugging
        """
        return tuple(j + i + k for i, (j, k) in zip(self.shape, self._halo))

    @cached_property
    def shape_allocated(self):
        """
        Shape of the allocated data of the Function type object from which
        this PETScArray was derived. It includes the domain and inhalo regions,
        as well as any additional padding surrounding the halo.

        Notes
        -----
        In an MPI context, this is the *local* with_halo region shape.
        """
        return DimensionTuple(*[j + i + k for i, (j, k) in zip(self._shape_with_inhalo,
                                                               self._padding)],
                              getters=self.dimensions)

    @cached_property
    def _C_ctype(self):
        # NOTE: Reverting to using float/double instead of PetscScalar for
        # simplicity when opt='advanced'. Otherwise, Temp objects must also
        # be converted to PetscScalar. Additional tests are needed to
        # ensure this approach is fine. Previously, issues arose from
        # mismatches between precision of Function objects in Devito and the
        # precision of the PETSc configuration.
        # TODO: Use cat $PETSC_DIR/$PETSC_ARCH/lib/petsc/conf/petscvariables
        # | grep -E "PETSC_(SCALAR|PRECISION)" to determine the precision of
        # the user's PETSc configuration.
        return POINTER(dtype_to_ctype(self.dtype))

    @property
    def symbolic_shape(self):
        field_from_composites = [
            FieldFromComposite('g%sm' % d.name, self.dmda.info) for d in self.dimensions]
        # Reverse it since DMDA is setup backwards to Devito dimensions.
        return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)

    @cached_property
    def dmda(self):
        return self._dmda
